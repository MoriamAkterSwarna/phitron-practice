# There are 2 types of Memory in Computer- 

## 1. Stack => Static Memory 
## 2. Heap => Dynamic Memory 


int x => 4 byte ;

int a[n] => {1,2,3,4,5}

All off the above are static memory. 



# Static Vs Dynamic Memory 

## Static 


1. memory limited 
2. Compile time memory => In compile time it reads the code and understand that how many memory it will need. 
3. It is not possible to increase static array size. 

4. Automatic memory clear. 


## Dynamic 

1. More memory 
2. Runtime 
3. Dynamic array size can increase. 

4. user instructed. 


# When to Use Dynamic array?? 

1. When we need more memory. It doesn't need for normal variable. 

2. When we will return an array from a function 


##


কম্পিউটারে দুই ধরনের মেমরি থাকে। স্ট্যাক মেমরি এবং হিপ মেমরি। স্ট্যাক মেমরিকে বলা হয় স্ট্যাটিক মেমরি এবং হিপ মেমরিকে বলা হয় ডায়নামিক মেমরি।


## 


স্ট্যাটিক মেমরি হচ্ছে কম্পাইলটাইম মেমরি। ডায়নামিক মেমরি হচ্ছে রানটাইম মেমরি। 
স্ট্যাটিক মেমরিতে সীমিত মেমরি থাকে তাই স্ট্যাটিক মেমরিতে কোন এরে ডিক্লেয়ার করা হলে সেটিকে বলা হয় স্ট্যাটিক এরে এবং তার সাইজ চাইলে বাড়ানো যায় না। স্ট্যাটিক মেমরি যত সাইজের এরে ডিক্লেয়ার করা হয়েছে মেমরিতে ঠিক ততটুকু স্পেসই দখল করে। তাই পরবর্তীতে চাইলেও স্ট্যাটিক এরের সাইজ বাড়ানো যায় না। 

ডায়নামিক মেমরিতে বেশি মেমরি থাকে তাই ডায়নামিক মেমরিতে কোন এরে ডিক্লেয়ার করা হলে সেটিকে বলা হয় ডায়নামিক এরে এবং তার সাইজ চাইলে বাড়ানো যায়। 


## 



স্ট্যাটিক এবং ডায়নামিক মেমরির আরেকটি পার্থক্য হচ্ছে স্ট্যাটিক মেমরি অটোমেটিক মেমরি ক্লিয়ার করে দেয় যা ডায়নামিক মেমরি করে না। স্ট্যাটিক মেমরিতে আমরা যদি কোন ফাংশনকে কল করে সেই ফাংশনের মধ্যে একটি স্ট্যাটিক এরে ডিক্লেয়ার করে সেটি মেইন ফাংশুনে রিটার্ন করে দেই, তাহলে দেখতে পাব মেইন ফাংশন থেকে সেই এরেকে এক্সেস করতে গেলে সব গারবেজ ভেলু পাওয়া যাচ্ছে। অর্থাৎ এরেটি ফাংশন থেকে রিটার্ন আসার পর স্ট্যাটিক মেমরি অটোমেটিক ফাংশনে থাকা এরে এবং সব ভেরিয়েবল ডিলিট করে দেয়। 
কিন্তু ডায়নামিক মেমরিতে আমরা যদি কোন ফাংশনকে কল করে সেই ফাংশনের মধ্যে একটি ডায়নামিক এরে ডিক্লেয়ার করে সেটি মেইন ফাংশুনে রিটার্ন করে দেই, তাহলে দেখতে পাব মেইন ফাংশন থেকে সেই এরের সব ভেলু পাওয়া যাচ্ছে।অর্থাৎ এরেটি ফাংশন থেকে রিটার্ন আসার পর ডায়নামিক মেমরি এরেটিকে ডিলিট করে দেয় নি। ডায়নামিক মেমরি ইউজার এর ইন্সট্রাকশন ছাড়া কোন মেমরি ডিলিট করে না। 

##


## স্ট্যাটিক মেমরিতে ভেরিয়বেল ডিক্লেয়ার করাঃ

```
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int x = 10;          // একটি ইন্টিজার ভেরিয়েবল ডিক্লেয়ার করে তাতে ১০ রেখে দেওয়া হচ্ছে। 
    cout << x << endl;   // ভেরিয়েবলটি প্রিন্ট করা হচ্ছে।
}

```


## ডায়নামিক মেমরিতে ভেরিয়েবল ডিক্লেয়ার করাঃ
ডায়নামিক মেমরিতে ভেরিয়েবল ডিক্লেয়ার করার সিন্টেক্সঃ 
data_type * pointer_name  = new data_type
এই সিন্টেক্স ফলো করলে ডায়নামিক মেমরিতে একটি ভেরিয়েবল ক্রিয়েট হয় এবং তার এড্রেস স্টোর থাকে পয়েন্টার এর মধ্যে। এখানে লক্ষণীয় ব্যাপার হচ্ছে পয়েন্টারটি কিন্তু স্টোর থাকে স্ট্যাটিক মেমরিতে। 

```
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int *x = new int;  // ডায়নামিক মেমরিতে একটি ইন্টিজার ভেরিয়েবল ডিক্লেয়ার হলো এবং তার এড্রেস স্টোর করা হচ্ছে p নামক পয়েন্টারে। 
    *x = 10;           // পয়েন্টারকে ডিরেফারেন্স করে ডায়নামিক মেমরিতে স্টোর থাকা ভেরিয়েবলের মধ্যে ১০ রেখে দেওয়া হচ্ছে। 
    cout << *x << endl;    // পয়েন্টারকে ডিরেফারেন্স করে ভেরিয়েবলটি প্রিন্ট করা হচ্ছে।
}
```
এভাবে আমরা ডায়নামিক মেমরিতে ভেরিয়েবল ক্রিয়েট করতে পারি।

##


এবার আমরা দেখব কিভাবে ডায়নামিক এরে ক্রিয়েট করতে হয় এবং ফাংশন থেকে রিটার্ন করতে হয়।

ডায়নামিক ভেরিয়েবল ডিক্লেয়ার এর মতো করেই আমরা ডায়নামিক এরে ডিক্লেয়ার করতে পারি। ডায়নামিক এরে আমরা নরমাল এরের মতোই ইনপুট নিতে পারব এবং আউটপুট শো করতে পারব।

``` 
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n; 
    cin >> n;        // এরে সাইজ ইনপুট নিচ্ছি। 
    int *a = new int[n];    // সেই সাইজের ডায়নামিক এরে ডিক্লেয়ার করছি যা হিপ মেমরিতে স্টোর থাকবে।
    for (int i = 0; i < n; i++)
    {
        cin >> a[i];             // নরমাল পদ্ধতিতে এরে ইনপুট নিচ্ছি। 
    }
    for (int i = 0; i < n; i++)
    {
        cout << a[i] << endl;    // নরমাল পদ্ধতিতে আউটপুট দেখাচ্ছি।
    }
    return 0;
}

```


আমরা যদি ফাংশনের মধ্যে একটি স্ট্যাটিক এরে ডিক্লেয়ার করে তা মেইন ফাংশনে রিটার্ন করতে চাইঃ

``` 
#include<bits/stdc++.h>
using namespace std;
int* fun()
{
    int a[5];               // ৫ সাইজের স্ট্যাটিক এরে ডিক্লেয়ার করা হয়েছে। 
    for(int i=0;i<5;i++)
    {
        cin >> a[i];       // ইউজার থেকে এরে এলিমেন্ট ইনপুট নেওয়া হচ্ছে। 
    } 
    return a;             // স্ট্যাটিক এরে রিটার্ন করে দেওয়া হচ্ছে। 
}
int main()
{
    int *p = fun();       // স্ট্যাটিক এরে রিসিভ করা হচ্ছে পয়েন্টার দিয়ে। 
    for(int i=0;i<5;i++)
    {
        cout << p[i] << " ";    // সেই পয়েন্টার দিয়ে এরে এলিমেন্ট প্রিন্ট করার চেষ্টা করা হচ্ছে।
    }
}

``` 


তাহলে আমরা দেখব কোড রান করলে সেগমেন্টেশন ফল্ট আসছে। যখনি ফাংশন থেকে রিটার্ন হয়ে আমরা মেইন ফাংশনে আসছি তখন ফাংশনে থাকা সব ভেরিয়েবল এবং এরে স্ট্যাক মেমরি অটো ডিলিট করে দিয়েছে। তাই আমরা যখন মেইন ফাংশন থেকে সেই এরে প্রিন্ট করার ট্রাই করছি তখন সেগমেন্টেশন ফল্ট আসছে কারন আমরা এমন মেমরি এক্সেস করার চেষ্টা করছি যা মেমরিতে নাই, ইতিমধ্যে ডিলিট হয়ে গিয়েছে। 
তাই আমাদের যদি ফাংশনের মধ্যে ডিক্লেয়ার করা এরে রিটার্ন করার প্রয়োজন হয় তাহলে আমরা ডায়নামিক এরে ডিক্লেয়ার করব। 

```
#include<bits/stdc++.h>
using namespace std;
int* fun()
{
    int* a = new int [5];     // ৫ সাইজের ডায়নামিক এরে ডিক্লেয়ার করা হয়েছে। 
    for(int i=0;i<5;i++) 
    {
        cin >> a[i];        // ইউজার থেকে এরে এলিমেন্ট ইনপুট নেওয়া হচ্ছে। 
    }
    return a;               // ডায়নামিক এরে রিটার্ন করে দেওয়া হচ্ছে। 
}
int main()
{
    int *p = fun();          // ডায়নামিক এরে রিসিভ করা হচ্ছে পয়েন্টার দিয়ে। 
    for(int i=0;i<5;i++)
    {
        cout << p[i] << " ";    // সেই পয়েন্টার দিয়ে এরে এলিমেন্ট প্রিন্ট করা হচ্ছে।
    }
}

``` 


এই কোডটি রান করলে আমরা দেখব ঠিকঠাক আউটপুট আসছে। এখানে আমরা এরে ডিক্লেয়ার করছি হিপ মেমরিতে তাই ফাংশন থেকে রিটার্ন হওয়ার পর হিপ মেমরি অটোমেটিক এরে ডিলিট করে দেয় নি। 